---
title: "Using dilution series to remove contamination"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using dilution series to remove contamination}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Scope and purpose

In this vignette, we will walk through how to use `tinyvamp` to estimate detection efficiencies and contamination using dilution series. 

# Comparing detection efficiencies across experiments

## Setup

We will start by loading the relevant packages. You might need to install `logsum` and `fastnnls` if you haven't already -- you can do this with `remotes::install_github("ailurophilia/logsum")` and `remotes::install_github("ailurophilia/fastnnls")`. Also, `speedyseq` is awesome, and you can get it with `remotes::install_github("mikemc/speedyseq")`. 

```{r setup}
library(tidyverse)
library(tinyvamp)
library(speedyseq)
# library(devtools)
# library(data.table)
# library(magrittr)()
# library(ggplot2)
# library(dplyr)
# library(Matrix)
# library(gridExtra)
```

Now let's load the relevant data and inspect it. This data is from [Karstens et al. (2019)](https://journals.asm.org/doi/full/10.1128/mSystems.00290-19?rfr_dat=cr_pub++0pubmed&url_ver=Z39.88-2003&rfr_id=ori%3Arid%3Acrossref.org), who generated 9 samples via three-fold dilutions of a synthetic community containing 8 distinct strains of bacteria which each account for 12.5% of the DNA in the community. Despite only 8 strains being present in the synthetic community, 248 total strains were identified using DADA2 (see Section 12.1 of [our paper](https://arxiv.org/pdf/2204.12733.pdf) for details on data processing). 

```{r}
data("karstens_phyloseq")
karstens_phyloseq
```

We can see the DNA concentrations and what-fold dilution each sample is as follows. 

```{r}
karstens_phyloseq %>% sample_data
```

Pull out column indices corresponding to taxa in the mock *TODO*

```{r}
genera_data <- karstens_phyloseq %>% tax_table %>% as_tibble %>% select("Genus") %>% pull
Pseudomonas <- genera_data %>% str_detect("Pseudomonas") %>% which
Escherichia <- genera_data %>% str_detect("Escherichia") %>% which
Salmonella <- genera_data %>% str_detect("Salmonella") %>% which
Limosilactobacillus <- genera_data %>% str_detect("Limosilactobacillus") %>% which
Enterococcus <- genera_data %>% str_detect("Enterococcus") %>% which
Staphylococcus <- genera_data %>% str_detect("Staphylococcus") %>% which
Listeria <- genera_data %>% str_detect("Listeria") %>% which
Bacillus <- genera_data %>% str_detect("Bacillus") %>% which
mock_taxa <- c(Pseudomonas,
               Escherichia,
               Salmonella[1],
               Enterococcus,
               Staphylococcus,
               Listeria,
               Bacillus,
               Limosilactobacillus)
```

We noted that there were some complexities regarding Salmonella, with two strains being detected: one strain as a likely mutant of synthetic community member *S. enterica*. For this reason we just consider the more prevalent Salmonella strain (hence the `Salmonella[1]` in the above). 

Construct count data matrix $W$. We reorder columns so taxa in mock come last, and reorder rows so dilutions in increasing order -- this just makes our lives easier later! *TODO*
 
```{r}
W <- karstens_phyloseq %>% otu_table %>% as.matrix
W <- cbind(W[,!(1:ncol(W) %in% mock_taxa)],
           W[,mock_taxa])
W <- W[order(rownames(W)),]
```

# Model setup 

In this vignette, we're doing to fit a model to all the data we have, and compare the estimated composition of the community to the known composition of the community. In contrast, if you want to evaluate the performance of `tinyvamp`'s fit, you might want to split your sample and do cross-validation, like we did in the paper. You can check out code for that [here](https://github.com/statdivlab/tinyvamp_supplementary/blob/main/karstens_cv.R), but note that it is more complicated! 

In this analysis, we are going to tell `tinyvamp` that

- the same specimen is analyzed in all nine samples (this is $\mathbf{Z}$)
- we are not interested in estimating detection efficiencies for contaminants (this is $\tilde{\mathbf{X}}$)
- there are eight taxa that are present in 12.5% abundance each, and that every other taxon is not present in the true composition of the sample (this is $\mathbf{p}$)

and we are going to ask `tinyvamp` to estimate

- the true relative abundance of the sample ($\mathbf{p}$)
- the contamination relative abundance profile ($\tilde{\mathbf{p}}$)
- the detection efficiencies for mock taxa ($\mathbf{\beta}$)

We're going to assume that

- every sample has the same contamination profile  (this is $\tilde{\mathbf{Z}}$)
- the ratio of expected contaminant reads to expected mock reads is proportional to the dilution number of the sample. (you can see support for this in Figure 2, upper right, of [the paper](https://arxiv.org/pdf/2204.12733.pdf)) Mo' dilution = less biomass = mo' problems! 

Ok, let's dive in! 

The same specimen is analyzed in all nine samples. The rows of $\mathbf{Z}$ represent the samples (of which there are nine), and the columns represent the distinct specimens (of which there is one). 

```{r}
Z <- matrix(1, ncol = 1, nrow = 9)
# colnames(Z) <- NULL
```

If you had a study where you had, let's say, two distinct specimens of different compositions to analyze, and 3 samples for each, your $\mathbf{Z}$ might look like $\begin{pmatrix} 1 & 0 \\ 1 & 0 \\ 1 & 0 \\ 0 & 1 \\ 0 & 1 \\ 0 & 1 \end{pmatrix}$. 

We are not interested in estimating detection efficiencies (see the Costea et al vignette if you want to learn to do that!): 

```{r}
X <- matrix(0, nrow = nrow(W), ncol = 1)
X_tilde <- matrix(0, nrow = 1, ncol = 1) # TODO(AW)
```

The true composition of the specimen is that there are eight taxa that are present in 12.5% abundance each, and we ordered them last. Everything else has 0\% abundance. 

```{r}
P <- matrix(c(rep(0,240), rep(1/8,8)), nrow = 1, ncol = ncol(W))
```

and we know this to be true ($\mathbf{p}$ is fixed): 

```{r}
P_fixed_indices <- matrix(TRUE, nrow = 1, ncol = ncol(W))
```

Note that `P_fixed_indices`, `B_fixed_indices`, etc., are how we tell `tinyvamp` if we *do* versus *do not* know the value of these parameters. So by specifying `P` and `P_fixed_indices` as above, we say "keep $\mathbf{p}$ fixed at the values that we tell you; you don't need to estimate it yourself!" 

In contrast, we do need to estimate *some* of the $\beta$'s, a.k.a. the detection efficiencies. We want to estimate the detection efficiencies of the mock taxa, but not for the contaminants. 

```{r}
B_fixed_indices <- matrix(TRUE, ncol = ncol(W), nrow = ncol(X))
B_fixed_indices[1, 241:247] <- FALSE
```

Hang on, why is $\beta_{248}$ fixed? Well, we always need some taxon to compare detection efficiencies to -- otherwise there's no difference between efficiencies 1, 2, and 4 versus 8, 16 and 32! (The fancy term for this is "identifiability constraint".) So here we're deciding to set *Limosilactobacillus fermentum* as the "baseline" taxon, which corresponds to the taxon in the last column of $\mathbf{W}$,

Remember that the $\beta$'s give the detection efficiencies on the log-scale, so let's set: 

```{r}
B <- matrix(0, ncol = ncol(W), nrow = 1)
```

Note that this analysis treats the contaminant taxa as having the same detection efficiency as *Limosilactobacillus fermentum*.

**If a parameter is** *not fixed* (e.g., $\beta_{241}$ in the above), **the corresponding value is where is** *initialized* **for the estimation algorithm to proceed.**

Ok, phew, that's most of the hard stuff! 

We *do* need to estimate the sampling intensity parameters (this will usually be the case). Let's initialize them at the log-total-read count (plus a bit of noise). 

```{r}
gammas_fixed_indices <- rep(FALSE, nrow(W))
gammas <- log(apply(W, 1, sum)) + rnorm(nrow(W))
```

Now let's talk contamination! We want to assume that the ratio of expected contaminant reads to expected mock reads is proportional to $3^{d}$, where $d$ is the dilution number of the sample ($d_i=0$ corresponds to the undiluted sample). To do this, we set $\tilde{\mathbf{Z}}_i$ proportional to $\exp(\gamma_i) \times 3^{d_i}$ for sample $i$. To address the $3^{d_i}$ piece, we set

```{r}
Z_tilde <- matrix(3^(0:8)/exp(mean(log(3^(0:8)))), ncol = 1)
```

and to address the $\exp(\gamma_i)$ piece, we set

```{r}
Z_tilde_gamma_cols <- 1 
```

<!-- TODO(AW) ask DC why both. Not doubling up on biomass info? I guess the gammas are estimated simultaneously across both pieces  -->

AW up to here

```{r}
### gamma_tilde
gamma_tilde <- matrix(0, nrow = 1, ncol = 1)
gamma_tilde_fixed_indices <- matrix(FALSE, ncol = ncol(gamma_tilde), nrow = nrow(gamma_tilde))
```

```{r}
### P_tilde
P_tilde <- matrix(1/ncol(W),ncol = ncol(W), nrow = 1)
P_tilde_fixed_indices <- matrix(FALSE,
                                ncol = ncol(P_tilde),
                                nrow = nrow(P_tilde))

# fix contaminants in mock to be zero
P_tilde[,ncol(P_tilde_fixed_indices)] <- 0

P_tilde_fixed_indices[,ncol(P_tilde_fixed_indices)] <- TRUE

P_tilde[1,!P_tilde_fixed_indices[1,]] <-  rexp(sum(!P_tilde_fixed_indices[1,]))
P_tilde[1,!P_tilde_fixed_indices[1,]] <- P_tilde[1,!P_tilde_fixed_indices[1,]]/sum(
    P_tilde[1,!P_tilde_fixed_indices[1,]]
  )
```

Now let's fit the model! 

```{r}
full_karstens_model <- estimate_parameters(W = W,
                                           X = matrix(1,ncol = 1, nrow = 9),
                                           Z = Z,
                                           Z_tilde = Z_tilde,
                                           Z_tilde_gamma_cols = Z_tilde_gamma_cols,
                                           gammas = gammas,
                                           gammas_fixed_indices = gammas_fixed_indices,
                                           P = P,
                                           P_fixed_indices = P_fixed_indices,
                                           B = B,
                                           B_fixed_indices = B_fixed_indices,
                                           X_tilde = X_tilde,
                                           P_tilde = P_tilde,
                                           P_tilde_fixed_indices = P_tilde_fixed_indices,
                                           gamma_tilde = gamma_tilde,
                                           gamma_tilde_fixed_indices = gamma_tilde_fixed_indices,
                                           criterion = "reweighted_Poisson")
```

```{r}
full_karstens_model %>% names
```

Wooohooo! 

```{r}
full_karstens_model$varying %>% as_tibble
```


```{r}
full_karstens_model$varying %>% pull(param) %>% unique
```


```{r}
# full_cis <- bootstrap_ci(W,
#                          fitted_model = full_karstens_model,
#                          n_boot = 100,
#                          parallelize = TRUE,
#                          seed  = 4323)
```

```{r}
# full_cis$ci %>%
#   filter(param == "B")
```


<!-- # Using cross-fold validation -->

<!-- ```{r} -->
<!-- ###### Construct helper function to specify models ###### -->
<!-- specify_dilution_model <- function( -->
<!--     samples_treated_as_known, -->
<!--     samples_treated_as_unknown, -->
<!--     intercept_in_Z_tilde = FALSE, -->
<!--     separate_dilution_series = FALSE, -->
<!--     use_alpha_tilde = FALSE, -->
<!--     beta_for_dilution = FALSE, -->
<!--     W){ -->
<!--   known_indicator <- as.numeric(1:9 %in% samples_treated_as_known) -->


<!--   dilutions <- 0:8 -->

<!--   ### -->
<!--   Z <- cbind(known_indicator, -->
<!--              1 - known_indicator) -->

<!--   colnames(Z) <- NULL -->

<!--   ### Z_tilde -->
<!--   # set up dilutions as covariate -->
<!--   Z_tilde <- matrix(3^(dilutions)/exp(mean(log(3^(0:8)))),ncol = 1) -->

<!--   # separate dilution covariate into two columns if needed -->
<!--   if(separate_dilution_series){ -->
<!--     Z_tilde <- cbind(Z_tilde[,1]*known_indicator, -->
<!--                      Z_tilde[,1]*(1 - known_indicator)) -->
<!--   } -->

<!--   # add intercept column if needed -->
<!--   if(intercept_in_Z_tilde){ -->
<!--     Z_tilde <- cbind(1, Z_tilde) -->
<!--   } -->

<!--   Z_tilde_gamma_cols <- 1:ncol(Z_tilde) -->

<!--   if(use_alpha_tilde){ -->

<!--     Z_tilde_list <- list( -->
<!--       known_indicator*Z_tilde[,ncol(Z_tilde),drop = FALSE], -->
<!--       (1 - known_indicator)*Z_tilde[,ncol(Z_tilde),drop = FALSE] -->
<!--     ) -->
<!--     if(intercept_in_Z_tilde){ -->
<!--       Z_tilde_list[[1]] <- cbind(1, Z_tilde_list[[1]]) -->
<!--       Z_tilde_list[[2]] <- cbind(0, Z_tilde_list[[2]]) -->
<!--     } -->
<!--     Z_tilde <- NULL -->
<!--     alpha_tilde <- rnorm(1) -->
<!--   } else{ -->
<!--     Z_tilde_list <- NULL -->
<!--     alpha_tilde <- NULL -->
<!--   } -->


<!--   ### gamma_tilde -->
<!--   K_tilde <- max(Z_tilde_gamma_cols) -->
<!--   gamma_tilde <- matrix(-5, nrow = K_tilde,ncol = 1) -->
<!--   gamma_tilde[] <- rnorm(K_tilde,-2) -->

<!--   gamma_tilde_fixed_indices <- matrix(FALSE, ncol = ncol(gamma_tilde), -->
<!--                                       nrow = nrow(gamma_tilde)) -->

<!--   ### P_tilde -->
<!--   P_tilde <- matrix(1/ncol(W),ncol = ncol(W), nrow = K_tilde) -->
<!--   P_tilde_fixed_indices <- matrix(FALSE, -->
<!--                                   ncol = ncol(P_tilde), -->
<!--                                   nrow = nrow(P_tilde)) -->

<!--   # fix contaminants in mock to be zero -->
<!--   P_tilde[,ncol(P_tilde_fixed_indices)] <- 0 -->

<!--   P_tilde_fixed_indices[,ncol(P_tilde_fixed_indices)] <- TRUE -->

<!--   for(k_tilde in 1:nrow(P_tilde)){ -->
<!--     P_tilde[k_tilde,!P_tilde_fixed_indices[k_tilde,]] <- -->
<!--       rexp(sum(!P_tilde_fixed_indices[k_tilde,])) -->
<!--     P_tilde[k_tilde,!P_tilde_fixed_indices[k_tilde,]] <- -->
<!--       P_tilde[k_tilde,!P_tilde_fixed_indices[k_tilde,]]/sum( -->
<!--         P_tilde[k_tilde,!P_tilde_fixed_indices[k_tilde,]] -->
<!--       ) -->
<!--   } -->

<!--   ### B -->
<!--   B <- matrix(0,ncol = ncol(W), -->
<!--               nrow = 1) -->

<!--   if(beta_for_dilution){ -->
<!--     B <- rbind(B,B) -->
<!--   } -->


<!--   B_fixed_indices <- matrix(TRUE,ncol = ncol(B),nrow = nrow(B)) -->
<!--   B_fixed_indices[,ncol(B) - 7:1] <- FALSE -->

<!--   B[!B_fixed_indices] <- rnorm(sum(!B_fixed_indices)) -->

<!--   ### X -->
<!--   X <- matrix(1,nrow = nrow(W),ncol = 1) -->
<!--   if(beta_for_dilution){ -->
<!--     X <- cbind(X,0:8) -->
<!--   } -->

<!--   ### X_tilde -->
<!--   X_tilde <- matrix(0, nrow = K_tilde, -->
<!--                     ncol = nrow(B)) -->

<!--   ### gammas -->

<!--   gammas <- log(apply(W,1,sum)) -->
<!--   gammas <- gammas + rnorm(length(gammas)) -->

<!--   gammas_fixed_indices <-rep(F,length(gammas)) -->

<!--   ### P -->
<!--   P <- rbind(c(rep(0,ncol(W) - 8), rep(1/8,8)), -->
<!--              rep(1/ncol(W),ncol(W))) -->

<!--   P_fixed_indices <- matrix(FALSE,ncol = ncol(W),nrow = 2) -->
<!--   P_fixed_indices[1,] <- TRUE -->

<!--   P[2,!P_fixed_indices[2,]] <- rexp(sum(!P_fixed_indices[2,])) -->
<!--   P[2,!P_fixed_indices[2,]] <-   P[2,!P_fixed_indices[2,]]/sum( -->
<!--     P[2,!P_fixed_indices[2,]] -->
<!--   ) -->


<!--   return(list( -->
<!--     "Z" = Z, -->
<!--     "Z_tilde" = Z_tilde, -->
<!--     "Z_tilde_gamma_cols" = Z_tilde_gamma_cols, -->
<!--     "P" = P, -->
<!--     "P_fixed_indices" = P_fixed_indices, -->
<!--     "gammas" = gammas, -->
<!--     "gammas_fixed_indices" = gammas_fixed_indices, -->
<!--     "X_tilde" = X_tilde, -->
<!--     "X" = X, -->
<!--     "B" = B, -->
<!--     "B_fixed_indices" = B_fixed_indices, -->
<!--     "P_tilde" = P_tilde, -->
<!--     "P_tilde_fixed_indices" = P_tilde_fixed_indices, -->
<!--     "gamma_tilde" = gamma_tilde, -->
<!--     "gamma_tilde_fixed_indices" = gamma_tilde_fixed_indices, -->
<!--     "alpha_tilde" = alpha_tilde, -->
<!--     "Z_tilde_list" = Z_tilde_list -->
<!--   )) -->

<!-- } -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ######## Three-fold CV ######## -->
<!-- folds <- cbind(c(1,4,7),c(2,5,8),c(3,6,9)) -->

<!-- fits <- vector(ncol(folds), -->
<!--                       mode = "list") -->

<!-- tries <- fits -->

<!-- for(try in 1:length(tries)){ -->
<!--   tries[[try]] <- vector(1,mode = "list") -->
<!-- } -->
<!-- set.seed(829343) -->

<!-- unknown_samples <- folds[,fold] -->
<!-- known_samples <- setdiff(1:9,unknown_samples) -->

<!-- inputs <- specify_dilution_model( -->
<!--   samples_treated_as_known = known_samples, -->
<!--   samples_treated_as_unknown = unknown_samples, -->
<!--   intercept_in_Z_tilde = FALSE, -->
<!--   separate_dilution_series = FALSE, -->
<!--   beta_for_dilution = FALSE, -->
<!--   use_alpha_tilde = TRUE, -->
<!--   W = W) -->

<!-- tries[[fold]][[try]] <- -->
<!--   estimate_parameters(W = W, -->
<!--                       X = inputs$X, -->
<!--                       Z = inputs$Z, -->
<!--                       Z_tilde = inputs$Z_tilde, -->
<!--                       Z_tilde_gamma_cols = inputs$Z_tilde_gamma_cols, -->
<!--                       gammas = inputs$gammas, -->
<!--                       gammas_fixed_indices = inputs$gammas_fixed_indices, -->
<!--                       P = inputs$P, -->
<!--                       P_fixed_indices = inputs$P_fixed_indices, -->
<!--                       B = inputs$B, -->
<!--                       B_fixed_indices = inputs$B_fixed_indices, -->
<!--                       X_tilde = inputs$X_tilde, -->
<!--                       P_tilde = inputs$P_tilde, -->
<!--                       P_tilde_fixed_indices = inputs$P_tilde_fixed_indices, -->
<!--                       gamma_tilde = inputs$gamma_tilde, -->
<!--                       gamma_tilde_fixed_indices = inputs$gamma_tilde_fixed_indices, -->
<!--                       alpha_tilde = inputs$alpha_tilde, -->
<!--                       Z_tilde_list = inputs$Z_tilde_list, -->
<!--                       barrier_t = 1, #starting value of reciprocal barrier penalty coef. -->
<!--                       barrier_scale = 10, #increments for value of barrier penalty -->
<!--                       max_barrier = 1e12, #maximum value of barrier_t -->
<!--                       initial_conv_tol = 1000, -->
<!--                       final_conv_tol = 0.1, -->
<!--                       final_f = 1e-6, -->
<!--                       constraint_tolerance = 1e-10, -->
<!--                       hessian_regularization = 0.01, -->
<!--                       criterion = "reweighted_Poisson", -->
<!--                       subproblem_method = "Newton", -->
<!--                       verbose = TRUE, -->
<!--                       profile_P = TRUE, -->
<!--                       profiling_maxit = 25, -->
<!--                       wts = NULL) -->


<!-- lls <- sapply(1:1, -->
<!--               function(x) tries[[fold]][[x]]$objective) -->
<!-- best_fit <- which.min(lls) -->

<!-- fits[[fold]] <- tries[[fold]][[best_fit]] -->


<!-- read_proportions <- vector(9, mode = "list") -->
<!-- names(read_proportions) <- paste("D",c(0:8), sep ="") -->
<!-- for(dilution in 0:8){ -->
<!--   read_counts <- W[paste("D",dilution, sep = "", collapse = ""),] -->
<!--   read_prop <- read_counts/sum(read_counts) -->
<!--   read_proportions[[dilution + 1]] <- read_prop -->
<!-- } -->

<!-- mock_taxa_names <- sapply(mock_taxa, -->
<!--                           function(x) paste(as.character( -->
<!--                             tax_table(karstens_phyloseq)[x,6:7]), -->
<!--                             sep = " ", -->
<!--                             collapse = " ")) -->

<!-- mock_taxa_names["ASV_1"] <- "Limosilactobacillus (species unclassified)" -->
<!-- values <- c(do.call(c,read_proportions), c(rep(0,240),rep(1/8,8))) -->
<!-- taxa_names <- c("Salmonella (species unclassified)", -->
<!--                 rep("Other",239), -->
<!--                 mock_taxa_names) -->
<!-- taxa_names <- factor(taxa_names, -->
<!--                      levels = c(mock_taxa_names, -->
<!--                                 "Salmonella (species unclassified)", -->
<!--                                 "Other")) -->
<!-- dilutions <- rep(c(0:8,"Theoretical"),each = 248) -->

<!-- observed_read_proportions <- -->
<!--   data.frame("Read_Proportions" = values, -->
<!--              "Taxon" = rep(taxa_names,10), -->
<!--              "Dilution" = as.character(dilutions)) -->

<!-- observed_read_proportions$Type <- sapply(observed_read_proportions$Dilution, -->
<!--                                          function(x) ifelse(x == "Theoretical", -->
<!--                                                             "Theoretical", -->
<!--                                                             "Observed")) -->

<!-- observed_props <- observed_read_proportions %>% -->
<!--   group_by(Dilution, Taxon, Type) %>% -->
<!--   summarize(Proportion = sum(Read_Proportions)) -->

<!-- karstens_3fold <- readRDS("karstens_3fold") -->


<!-- fitted_proportions_3fold <- karstens_3fold %>% -->
<!--   filter(param == "P") %>% -->
<!--   select(c("value","Fold","j")) %>% -->
<!--   mutate("Taxon" = sapply(j,function(x) -->
<!--     ifelse(x<241 & x>1,"Other", -->
<!--            ifelse(x == 241, -->
<!--                   "P. aeruginosa", -->
<!--                   ifelse(x == 242, -->
<!--                          "E. coli", -->
<!--                          ifelse(x == 243, -->
<!--                                 "S. enterica", -->
<!--                                 ifelse(x == 244, -->
<!--                                        "E. faecium", -->
<!--                                        ifelse(x == 245, -->
<!--                                               "S. aureus", -->
<!--                                               ifelse(x == 246, -->
<!--                                                      "L. monocytogenes", -->
<!--                                                      ifelse(x == 247, -->
<!--                                                             "B. halotolerans", -->
<!--                                                             ifelse(x == 248, -->
<!--                                                                    "L. fermentum", -->
<!--                                                                    "S. [unclassified]"))))))))))) -->


<!-- fitted_proportions_3fold$Taxon %<>% -->
<!--   factor(levels = c("P. aeruginosa", -->
<!--                     "E. coli", -->
<!--                     "S. enterica", -->
<!--                     "L. fermentum", -->
<!--                     "E. faecium", -->
<!--                     "S. aureus", -->
<!--                     "L. monocytogenes", -->
<!--                     "B. halotolerans", -->
<!--                     "S. [unclassified]", -->
<!--                     "Other")) -->

<!-- taxon_conversion <- cbind(c("P. aeruginosa", -->
<!--                             "E. coli", -->
<!--                             "S. enterica", -->
<!--                             "E. faecium", -->
<!--                             "S. aureus", -->
<!--                             "L. monocytogenes", -->
<!--                             "B. halotolerans", -->
<!--                             "L. fermentum", -->
<!--                             "S. [unclassified]", -->
<!--                             "Other"), -->
<!--                           c( -->
<!--                             "Pseudomonas aeruginosa", -->
<!--                             "Escherichia-Shigella coli", -->
<!--                             "Salmonella enterica", -->
<!--                             "Enterococcus faecium", -->
<!--                             "Staphylococcus aureus", -->
<!--                             "Listeria monocytogenes", -->
<!--                             "Bacillus halotolerans", -->
<!--                             "Limosilactobacillus (species unclassified)", -->
<!--                             "Salmonella (species unclassified)", -->
<!--                             "Other")) -->



<!-- observed_props$Taxon <- sapply(observed_props$Taxon, -->
<!--                                function(d) taxon_conversion[taxon_conversion[,2]==d,1]) -->

<!-- observed_props <- cbind(observed_props[,1:3], -->
<!--                         data.frame("Fold" = -->
<!--                                      sapply(observed_props$Type, -->
<!--                                             function(x) -->
<!--                                               ifelse(x == "Observed", -->
<!--                                                      x, -->
<!--                                                      "Theoretical \nComposition"))), -->

<!--                         observed_props[,4]) -->

<!-- fitted_props_3fold <- data.frame("Dilution" = "Not Applicable", -->
<!--                                  "Taxon" = fitted_proportions_3fold$Taxon, -->
<!--                                  "Type" = "Fitted", -->
<!--                                  "Fold" = fitted_proportions_3fold$Fold, -->
<!--                                  "Proportion" = fitted_proportions_3fold$value) -->

<!-- results_taxa_lumped_3fold <- rbind(observed_props, -->
<!--                                    fitted_props_3fold) -->

<!-- results_taxa_lumped_3fold$Taxon %<>% -->
<!--   factor(levels = c("P. aeruginosa", -->
<!--                     "E. coli", -->
<!--                     "S. enterica", -->
<!--                     "L. fermentum", -->
<!--                     "E. faecium", -->
<!--                     "S. aureus", -->
<!--                     "L. monocytogenes", -->
<!--                     "B. halotolerans", -->
<!--                     "S. [unclassified]", -->
<!--                     "Other")) -->

<!-- lumped_taxa <- unique(results_taxa_lumped_3fold$Taxon) -->
<!-- names(lumped_taxa) <- c("P. aeruginosa", -->
<!--                         "E. coli", -->
<!--                         "S. enterica", -->
<!--                         "E. faecium", -->
<!--                         "S. aureus", -->
<!--                         "L. monocytogenes", -->
<!--                         "B. halotolerans", -->
<!--                         "L. fermentum", -->
<!--                         "S. [unclassified]", -->
<!--                         "Other") -->
<!-- results_taxa_lumped_3fold$nice_taxon <- factor(sapply(results_taxa_lumped_3fold$Taxon, -->
<!--                                                 function(x) names(lumped_taxa)[lumped_taxa ==x] ), -->
<!--                                          levels = c("P. aeruginosa", -->
<!--                                                     "E. coli", -->
<!--                                                     "S. enterica", -->
<!--                                                     "L. fermentum", -->
<!--                                                     "E. faecium", -->
<!--                                                     "S. aureus", -->
<!--                                                     "L. monocytogenes", -->
<!--                                                     "B. halotolerans", -->
<!--                                                     "S. [unclassified]", -->
<!--                                                     "Other")) -->

<!-- # results_taxa_lumped_3fold %>% View() -->
<!-- # observed_proportions <- -->


<!-- fitted_prop_plot <- -->
<!--   results_taxa_lumped_3fold %>% -->
<!--   mutate(Fold = sapply(Fold, function(x) ifelse( -->
<!--     x%in% 1:3, -->
<!--     paste("Fold ",x, -->
<!--                                                sep = "", -->
<!--                                                collapse = ""), -->
<!--     x))) %>% -->
<!--   # filter(Fitted=="Observed") %>% -->
<!--   filter(Fold != "Observed") %>% -->
<!--   # filter(Type %in% c("Fitted","Theoretical")) %>% -->
<!--   ggplot() + -->
<!--   geom_point(aes(x= Taxon, y = Proportion), -->
<!--              size = .5) + -->
<!--   geom_line(aes(x= Taxon, y = Proportion, -->
<!--                 group = interaction(Dilution,Fold), -->
<!--                 linetype = Type, -->
<!--                 color = Fold))+ -->
<!--   theme_bw() + -->
<!--   guides(linetype = guide_legend(ncol = 1, -->
<!--                                  keyheight=0.15, -->
<!--                                  default.unit="inch"), -->
<!--          color = guide_legend(ncol = 1, -->
<!--                               keyheight=0.1, -->
<!--                               default.unit="inch")) + -->
<!--   theme(axis.text.x = element_text(angle = 45,  hjust=1), -->

<!--         legend.spacing.y = unit(0.25, 'cm')) + -->
<!--   scale_color_manual(values = sequential_hcl(4, palette = "LightGrays")[4:1]) + -->
<!--   guides(linetype=guide_legend(title="Type")) + -->
<!--   xlab("Taxon") + -->
<!--   ylab("Proportion") + -->
<!--   ylim(c(0,.8)) -->


<!-- observed_prop_plot <- -->
<!--   results_taxa_lumped_3fold %>% -->
<!--   # filter(Fitted=="Observed") %>% -->
<!--   filter(!(Fold %in% 1:3)) %>% -->
<!--   # filter(Type %in% c("Fitted","Theoretical")) %>% -->
<!--   ggplot() + -->
<!--   geom_point(aes(x= Taxon, y = Proportion), -->
<!--              size = .5) + -->
<!--   geom_line(aes(x= Taxon, y = Proportion, -->
<!--                 group = interaction(Dilution,Fold), -->
<!--                 linetype = Type, -->
<!--                 color = Dilution))+ -->
<!--   theme_bw() + -->
<!--   guides(linetype = guide_legend(ncol = 1, -->
<!--                                  keyheight=0.15, -->
<!--                                  default.unit="inch"), -->
<!--          color = guide_legend(ncol = 1, -->
<!--                               keyheight=0.1, -->
<!--                               default.unit="inch")) + -->
<!--   theme(axis.text.x = element_text(angle = 45,  hjust=1), -->

<!--         legend.spacing.y = unit(0.25, 'cm')) + -->
<!--   scale_color_manual(values = sequential_hcl(12, palette = "LightGrays")[c(1:9,1)]) + -->
<!--   guides(linetype=guide_legend(title="")) + -->
<!--   xlab("Taxon") + -->
<!--   ylab("Proportion") + -->
<!--   ylim(c(0,.8)) -->
<!-- ``` -->

## References

- Karstens, L., Asquith, M., Davin, S. et al. Controlling for Contaminants in Low-Biomass 16S rRNA Gene Sequencing Experiments. *mSystems* **4**(4):e00290-19 (2019). doi: 10.1128/mSystems.00290-19. 
- Clausen, D.S. and Willis, A.D. Modeling complex measurement error in microbiome experiments. *arxiv* 2204.12733. https://arxiv.org/abs/2204.12733. 